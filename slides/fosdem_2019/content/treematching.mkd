% Tree matchings with Behavior Trees
% FOSDEM 2019

How to recognize a complex subtree in a big tree

![](sample_tree.png){#id .class width=130}

lionel@lse.epita.fr
FOSDEM - Python Devroom 2019 ![Sequence](gear_logo.png){#id .class width=30}

# Quick summary

* About Behavior Tree
* About Tree Matching...
* ...in python

# About Behavior Tree

A powefull abstraction to defined Process.

Common in Video Game to implement BOT AI.

![](behavior_tree.png){#id .class width=60% }

# About Behavior Tree

3 components:

* Task \
    Do a simple thing \
    ![Task](task.png){#id .class width=40}
* Sequence \
    Do the next if the previous succeed \
    ![Sequence](sequence.png){#id .class width=160 }
* Selector \
    Do the next if the previous failed \
    ![Selector](selector.png){#id .class width=160 }

# About Behavior Tree

## Task

```python
from enum import IntEnum

Status = IntEnum('Status', [
            'Failure',
            'Success',
            'Running'
    ])

class Task:
    def tick(self, udata) -> Status:
        return Status.Success

class Tree:
    def __init__(self, *child):
        self.child = child
```

# About Behavior Tree

## Sequence

```python
class Sequence(Tree):
    def tick(self, udata) -> Status:
        for child in self.child:
            childstatus = child.tick(udata)
            if childstatus == Status.Running:
                return Status.Running
            elif childstatus == Status.Failure:
                return Status.Failure
        return Status.Success
```

# About Behavior Tree

## Selector

```python
class Selector(Tree):
    def tick(self, udata) -> Status:
        for child in self.child:
            childstatus = child.tick(udata)
            if childstatus == Status.Running:
                return Status.Running
            elif childstatus == Status.Success:
                return Status.Success
        return Status.Failure
```

# About Behavior Tree

Base on few principe, you could easlisy create your own abstraction

# About Behavior Tree

## Concurrent

\small

```python
class Concurrent(Tree):
    def tick(self, udata) -> Status:
        for idx, child in enumerate(self.child):
            if self.status[idx] == Status.Running:
                self.status[idx] = child.tick(udata)
        if (not sum(map(lambda _: _ == Status.Running,
             self.status))):
            if (sum(map(lambda _: _ == Status.Success,
                 self.status))):
                return Status.Success
            return Status.Failure
        return Status.Running
```

# About Tree Matching

Use cases:

* Data Validation
* Data Transformation
* Data Generation

All in Compiler (AST)

# About Tree Matching

Tree Handling:

- Descent recursive function (Tree Walk)
- Pattern Matching:
    * Identify nodes
    * Deconstruct it and do something
- Top-down

# About Tree Matching

Top-down pattern matching is it enough?

Tree Reconstruction (update tree during walking) -> Bottom-Up

# About Tree Matching

Intuition: Using BT to match subtree?

* Behavior Tree mimic matching subtree
* Versatile (Top-Down and/or Bottom-Up)


# Handle Python tree

Get a generic python data tree
```python
class A:
    def __init__(self, **kw):
        self.__dict__.update(kw)

class B(dict):
    def __init__(self, d, **kw):
        self.update(d)
        self.__dict__.update(kw)

class C(list):
    def __init__(self, l, **kw):
        self.extend(l)
        self.__dict__.update(kw)
```

# Handle Python tree

```python
a = A(foo=42,
        bar=C([
                1, 2, 3,
                B(h={'low': 1.2, 'high': 3.4}),
                4, 5, 6
            ],
            meh=3
            )
    )
```

# Handle Python tree

Separation of concern:

![](matching_process.png){#id .class}

# Handle Python tree

To handle it

* vars
* getattr
* collections.Mapping
* collections.Iterable
* yield

# Handle Python tree

A generic walking function
\small

```python
def walk(tree):
    if isinstance(tree, c.Mapping):
        lsk = list(sorted(tree.keys()))
        for k in lsk:
            yield from walk(tree[k])
            ...
    elif (isinstance(tree, c.Iterable) \
          and type(tree) not in {str, bytes}):
        ls = enumerate(tree)
        for idx, it in ls:
            yield from walk(it)
            ...
    if hasattr(tree, '__dict__'):
        attrs = vars(tree)
        for attr in sorted(attrs.keys()):
            yield from walk(attrs[attr])
            ...
    ...
```

# Handle Python tree

Notification

```python
('value', tree)
('type', tree)
('attr', attr)
('key', k)
('idx', idx)
```

# Handle Python tree

Behavior Tree Item:

* List: Sequence of value/idx
* Dict: Sequence of value/key
* Attributes: Sequence of value/attr
* Type: Concurrent Attributes/List/Dict

1 pattern = 1 BT

Don't store matching state IN the BT!

# Handle Python tree

Module __treematching__

```python
bt = AnyType(
            List(
                AnyIdx(Type(str, Value('lala'))),
                AnyIdx(Type(int, Value(666))),
            ),
            Attrs(
                Attr('foo', Type(int, AnyValue()))
            )
    )
e = MatchingBTree(bt)
...
match = e.match(tree)
```

# Conclusion

\huge \center

**Q/A!**

\normalsize

\justify

\tiny

* **[slides](https://github.com/LionelAuroux/pyrser/treematching/slides/fosdem\_2019/content/treematching.pdf)**

* **[https://github.com/LionelAuroux/treematching](https://github.com/LionelAuroux/treematching)**
